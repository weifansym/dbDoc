##  创建高性能索引
### 5.1 索引类型
#### B-Tree
B-Tree通常意味着所有的值都是按照顺序存储（因此非常适合做范围查询），而且每个叶子页到跟的距离相同。
树的深度和表的大小直接相关。

B-Tree中多列构建的索引中，索引中列的顺序对查询有很大影响。

#### Hash
哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。
在mysql中只有Memory引擎显示支持哈希索引，这个也是Memory引擎的默认索引类型
InnoDB也支持哈希索引，但是他的哈希索引值在B-Tree索引的基础上构建的（具体请看官方文档）。

### 5.2 索引的优点
索引可以让数据库服务器快速定位到表的指定位置，但是这并不是索引的唯一作用，其实索引也有一些其他的附加作用。
常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree
也就会将相关的列值储存在一起。

总结起来索引有如下优点：
1：
评价一个索引是否符合某个查询的“三星系统”：索引将相关记录放到一起则获得一星；如果索引中的数据顺序和查找中的排列顺序一致则获得二星；
如果索引中的列包含了查询中需要的全部列则获得三星。
### 5.3 高性能的索引策略

#### 5.3.1 独立的列
独立的列是指索引不能使表达式的一部分，也不能是函数的参数。下面两种形式是不能使用索引的：
```
1：SELECT id, status FROM tbl_live_room WHERE id + 1 =1900;
2：SELECT ... WHERE TO_DAYS(start_time) - TO_DAYS(start_time) <= 10;
```
#### 5.3.2 前缀索引与索引选择性
具体参见《高性能Mysql 第三版》中相应章节。
前缀索引是一种能使索引更小，更快的有效方法，但另一方面也有缺点：mysql无法使用前缀索引做**ORDER BY** 和**GROUP BY**,
也无法使用前缀索引做覆盖扫描。

添加前缀索引如下：
```
ALTER TABLE tbl_live_room ADD KEY (cover(7));
```
#### 5.3.3 多列索引
很多人对多列索引的理解都不够，一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。

哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效的
#### 5.3.4 选择合适的索引列顺序
正确的索引顺序依赖于使用该索引的查询，并且同时需要考虑如何更好的满足排序和分组的需要。

在一个多列的B-Tree索引中，索引列的顺序意味着索引首先按照最左进行排序，其次是第二列，等等。所以，索引们可以按照升序或者降序进行扫描，以满足
精确符合列顺序的ORDER BY,GROUP BY和DISTINCT等字句的查询需求。

所以多列索引的列顺序至关重要。
接下来看书上说的就好。
#### 5.3.5 聚簇索引
聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体细节依赖于其实现方式，但InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。

当表有聚簇索引时，它的数据行实际上存放在索引的叶子页中。术语“聚簇”表示数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行存放在两个不同的地方，
所以一个表只能有一个聚簇索引（不过，覆盖索引可以模拟多个聚簇索引的情况）。因为是存储引擎负责实现索引。
