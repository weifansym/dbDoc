##  创建高性能索引
### 5.1 索引类型
#### B-Tree
B-Tree通常意味着所有的值都是按照顺序存储（因此非常适合做范围查询），而且每个叶子页到跟的距离相同。
树的深度和表的大小直接相关。

B-Tree中多列构建的索引中，索引中列的顺序对查询有很大影响。

#### Hash
哈希索引（hash index）基于哈希表实现，只有精确匹配索引所有列的查询才有效。
在mysql中只有Memory引擎显示支持哈希索引，这个也是Memory引擎的默认索引类型
InnoDB也支持哈希索引，但是他的哈希索引值在B-Tree索引的基础上构建的（具体请看官方文档）。

### 5.2 索引的优点
索引可以让数据库服务器快速定位到表的指定位置，但是这并不是索引的唯一作用，其实索引也有一些其他的附加作用。
常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。因为数据是有序的，所以B-Tree
也就会将相关的列值储存在一起。

总结起来索引有如下优点：
1：
### 5.3 高性能的索引策略

#### 5.3.1 独立的列
独立的列是指索引不能使表达式的一部分，也不能是函数的参数。下面两种形式是不能使用索引的：
```
1：SELECT id, status FROM tbl_live_room WHERE id + 1 =1900;
2：SELECT ... WHERE TO_DAYS(start_time) - TO_DAYS(start_time) <= 10;
```
#### 5.3.2 前缀索引与索引选择性
具体参见《高性能Mysql 第三版》中相应章节。
前缀索引是一种能使索引更小，更快的有效方法，但另一方面也有缺点：mysql无法使用前缀索引做**ORDER BY** 和**GROUP BY**,
也无法使用前缀索引做覆盖扫描。

添加前缀索引如下：
```
ALTER TABLE tbl_live_room ADD KEY (cover(7));
```
#### 5.3.3 多列索引
很多人对多列索引的理解都不够，一个常见的错误就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。
