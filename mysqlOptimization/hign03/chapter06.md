## 查询性能优化
前面我们介绍了如何设计最优的库表结构，如何建立最好的索引，这些对于高性能来说是必不可少的。但这些还不够--还需要合理的设计查询。如果查询写的糟糕，即使库表结构在合理，索引在合适，也无法实现高性能。
### 6.1 为什么查询速度会慢
### 6.2 慢查询优化基础：优化数据访问
#### 6.2.1 是否向数据库请求了不需要的数据
#### 6.2.2 mysql是否在扫描额外的记录
### 6.3 重构查询的方式
在优化有问题的查询时，目标应该是找到一个更优的方法获得实际需要的结果--而不是总是需要从MySQL获取一模一样的结果集。有时候，可以将查询换一种写法让其返回一样的结果集，但性能更好。但也可以通过修改代码通过另一种方式来达到目的。
#### 6.3.1 一个复杂查询还是多个简单查询
#### 6.3.2 切分查询
#### 6.3.3 分解关联查询
很多高性能应用都会对关联查询进行分解。简单地，可以对每个表进行一次单表查询，然后将结果在应用程序中做关联。事实上通过分解关联查询的方式来重构查询有如下又是：
* 让缓存的效率更高：许多应用程序可以方便的缓存单表查询对应的结果对象（例如使用应用程序本身的来缓存或者使用缓存工具）。另外，对mysql的查询缓存来说，
如果关联中的某个表发生了变化，那么就无法使用查询缓存了，而拆分后，如果某个表很少变化，那么基于该表的查询就可以重复利用查询缓存结果了。
* 将查询拆分后，执行单个查询可以减少锁的竞争。（防止出现死锁，所等待等的消耗）
* 在应用层做关联，可以更容易对数据库进行拆分，更容易做到高性能和可扩展。
* 查询本身的效率也可能提升。在这儿例子中，使用**IN()** 来代替关联查询，可以让mysql可以按照ID顺序进行查询，这可能比随机的关联更高效。
* 可以减少冗余记录的查询。在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复的访问一部分数据。
* 更进一步，这样做相当于在应用中实现了哈希关联，而不是使用mysql的嵌套循环关联。某些场景哈希关联的效率要高的多。

在很多场景下，通过查询重构将关联放在应用程序中将会更加高效，这样的场景很多，比如：当应用可以方便的缓存单个结果的时候，当可以将数据分布到不同的mysql服务器的时候，当能够使用IN()的方式代替关联查询的时候，当查询中使用到同一个表的时候。
### 6.4 查询执行的基础
当希望MySQL能够以更高性能运行查询时，好的办法就是弄清楚MySQL是如何优化和执行查询的。一旦理解了这一点，很多查询优化工作实际上就是遵循一些原则让优化器
能够按照预想的合理的方式运行。具体的执行过程请参加《高性能mysql第3版》对应章节。
1. 客户端发送一条查询给服务器
2. 服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果，否则进入下一个阶段。
3. 服务器进行sql解析，预处理，再有优化器生成对应的执行计划。
4. Mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询。
5. 将结果返回给客户端。

上面的每一步都比想想中复杂，我们会在后续章节中继续讨论。我们会看到在每一阶段查询处于什么状态。
#### 6.4.1 Mysql客户端/服务器通信
##### 查询状态
对于一个Mysql链接，或者说一个线程，任何时刻都有一个状态，该状态表示了mysql当前正在做什么。有很多种方式能查看当前状态，最简单的是使用**SHOW FULL PROCESSLIST**命令（该命令返回结果中的Command列就表示当前状态）。在一个查询的声明周期中，状态变化会发生很多次。mysql官方手册对这些状态值得解释最具
权威性，下面将这些状态列出来，并做一个简单的解释。
* Sleep: 线程正在等待客户端发送新的请求
* Query: 线程正在执行查询或正在将结果发送给客户端
* Locked: 在Mysql服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如InnoDB的行锁，并不会体现在线程状态中。对于MyISAM来说就是一个比较典型的
状态，但在其他没有行锁的引擎中也经常会出现。
* Analyzing and statistics: 线程正在收集存储引擎的统计信息，并生成查询的执行计划。
* Copying to tmp table [on disk]: 线程正在执行查询，并且将其结果集都复制到一个临时表中，这种状态一般要么是在做**GROUP BY**，要么是文件排序操作。或者是**UNION**操作。如果这个状态后面还有“on disk”标记，那表示mysql正在将一个内存临时表放在磁盘上。
* Sorting result: 线程 正在对结果集进行排序
* Sending data: 这表示多种情况：线程可能在多个状态之间传送数据，或者在生成结果集，或者在向客户端返回数据。

了解这些状态的基本含义非常有用，这可以让你很快的了解当前mysql服务器所处的状态。在一个繁忙的服务器上可能出现大量不正常的状态。例如：statistics
正占用大量的时间。这通常表示，某个地方有异常了。可以通过第三章介绍的技巧来分析诊断到底那个环节出现了问题。
#### 6.4.2 查询缓存
在解析一个查询语句之前，如果查询缓存是打开的，那么mysql会优先检查这个查询是否命中查询缓存中的数据。这个检查是通过一个对大小写敏感的哈希查找实现的。
查询和缓存中的查询即使只有一个字节不同，那也不会匹配缓存结果，这种情况下查询会进入下一个阶段进行处理。

#### 6.4.3 查询优化处理
查询的生命周期的下一步是将一个sql转换成一个执行计划，Mysql在依照这个执行计划和存储引擎进行交互。这包括多个子阶段：解析sql，预处理，优化sql执行计划。
这个过程中任何错误都可能终止查询。
